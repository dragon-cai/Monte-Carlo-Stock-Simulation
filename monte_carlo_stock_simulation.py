# -*- coding: utf-8 -*-
"""Monte Carlo Stock Simulation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZJNSp6y7QE-7-F39OgSdVk9TI_NJBUJT
"""



import numpy as np
import pandas as pd
import yfinance as yf
import logging
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
logging.getLogger("yfinance").setLevel(logging.CRITICAL)



# set dynamic 5 year historical period
end_date = datetime.today()
# yf.download end parameter is exclusive
end_date_yf = end_date + timedelta(days = 1)
start_date = end_date.replace(year = end_date.year - 5)

end_date_yf = end_date_yf.strftime("%Y-%m-%d")
start_date_yf = start_date.strftime("%Y-%m-%d")

start_date = start_date.strftime("%B %d, %Y")
end_date = end_date.strftime("%B %d, %Y")


ticker_exist = False
# repeat prompt until ticker valid
while not ticker_exist:
  ticker = input("Enter Stock Ticker (e.g. AMZN): ").upper()
  try:
    # download Yahoo Finance stock data
    data = yf.download(ticker, start=start_date_yf, end=end_date_yf, auto_adjust = True)
    if(not data.empty):
      ticker_exist = True
    else:
      print("Invalid Ticker. Please Try Again")
  except Exception:
    print("Invalid Ticker. Please Try Again")

if isinstance(data.columns, pd.MultiIndex):
    data.columns = data.columns.droplevel(1)


correct_time = False
# prompt user for dynamic forecast horizon
while not correct_time:
  forecast_day = input("Enter the forecast horizon in trading days within the next year (1 - 252): ")
  try:
    forecast_day = int(forecast_day)
    if(forecast_day >= 1 and forecast_day <= 252):
      correct_time = True
    else:
      print("Please enter a value between 1 and 252")
  except ValueError:
    print("Please enter a numeric value between 1 and 252")


# plot graph of closing prices
plt.figure(figsize=(10,6))
plt.plot(data["Close"], label = "Close Price")
plt.title(f"Closing Price of {ticker} since {start_date}")
plt.xlabel("Date")
plt.ylabel("Closing Price")
plt.legend()
plt.grid(True)
plt.show()


def calculate_return(data):
  # pct_change() = (Pt - Pt-1)/Pt-1 = (Pt/Pt-1) - 1
  # pct.change() + 1 to get daily return = (Pt/Pt-1)
  close_prices = data["Close"].squeeze()
  log_return = np.log(close_prices.pct_change() + 1)
  # remove first pct_change value of NaN, no previous day's price
  log_return = log_return[1:]
  return log_return


# plot daily log returns
log_return = calculate_return(data)
plt.figure(figsize = (10,6))
plt.plot(log_return, label = "Daily Log Returns")
plt.title(f"Daily Log Returns of {ticker} since {start_date}")
plt.xlabel("Date")
plt.ylabel("Log Return")
plt.legend()
plt.grid(True)
plt.show()


annual_drift = log_return.mean() * 252
annual_drift = annual_drift.item()

annual_volatility = log_return.std() * np.sqrt(252)
annual_volatility = annual_volatility.item()

# 252 trading days in 1 year
num_days = 252

# one trading day
time_step = 1/252

# num of simulated futures
num_simulations = 10000

last_price = data["Close"].iloc[-1]
last_price = last_price.item()


def monteCarlo(drift, volatility, num_days, num_simulations, last_price, dt):
  # random shocks
  Z = np.random.normal(size = (num_days + 1, num_simulations))
  simulated = np.zeros((num_days + 1, num_simulations))
  simulated[0, :] = last_price
  for day in range(1, num_days + 1):
    # Geometric Brownian Motion formula
    simulated[day, :] = simulated[day-1, :] * np.exp((drift - 0.5*volatility**2)*(dt) + volatility*(np.sqrt(dt))*Z[day, :])
  return simulated

all_paths = monteCarlo(annual_drift, annual_volatility, num_days, num_simulations, last_price, time_step)


# plot Monte Carlo graph
graph = pd.DataFrame(all_paths)
graph.plot(legend = False, figsize=(12, 7))
plt.title(f"Monte Carlo Simulation for {ticker}")
plt.axhline(y = last_price, color = 'r', linestyle= '-')
plt.xlabel("Trading Day")
plt.ylabel("Price")
plt.grid(True)
plt.show()


# output variables
median_price = np.median(all_paths[forecast_day, :])
median_return = (median_price - last_price) / last_price
p5 = np.percentile(all_paths[forecast_day, :], 5)
p25 = np.percentile(all_paths[forecast_day, :], 25)
p25_return = (p25 - last_price) / last_price
p75 = np.percentile(all_paths[forecast_day, :], 75)
p75_return = (p75 - last_price) / last_price
p95 = np.percentile(all_paths[forecast_day, :], 95)
profit = np.sum(all_paths[forecast_day, :] > last_price)/num_simulations
ten_gain = np.sum(all_paths[forecast_day, :] > last_price * 1.1) / num_simulations
ten_loss = np.sum(all_paths[forecast_day, :] < last_price * 0.9) / num_simulations
var = last_price - p5

final_median_price = np.median(all_paths[-1, :])
final_return = (final_median_price - last_price) / last_price
final_p5 = np.percentile(all_paths[-1, :], 5)
final_p25 = np.percentile(all_paths[-1, :], 25)
final_p25_return = (final_p25 - last_price) / last_price
final_p75 = np.percentile(all_paths[-1, :], 75)
final_p75_return = (final_p75 - last_price) / last_price
final_p95 = np.percentile(all_paths[-1, :], 95)
final_profit = np.sum(all_paths[-1, :] > last_price)/num_simulations
final_ten_gain = np.sum(all_paths[-1, :] > last_price * 1.1) / num_simulations
final_ten_loss = np.sum(all_paths[-1, :] < last_price * 0.9) / num_simulations
final_var = last_price - final_p5




print(f"\n================= MONTE CARLO SIMULATIONS RESULTS FOR {ticker} =================")
print("\n--- Model Parameters ---")
print(f"Number of Simulations: {num_simulations:,}")
print(f"Forecast Horizon: {num_days} trading days")
print(f"Historical data of last 5 years from {start_date} to {end_date}:")
print(f"Annual Drift (μ): {annual_drift:.2%}")
print(f"Annual Volatility (σ): {annual_volatility:.2%}")
print(f"Current Price on {end_date}: ${last_price:.2f}")

print(f"\n--- Forecast Results in {forecast_day} Business Days ---")
print(f"Median Simulated Price: ${median_price:.2f}")
print(f"Median Return: {median_return:+.2%}")
print(f"25% Percentile: ${p25:.2f} ({p25_return:+.2%})")
print(f"75% Percentile: ${p75:.2f} ({p75_return:+.2%})")
print(f"90% Confidence Interval: (${p5:.2f}, ${p95:.2f})")
print(f"Probability of Profit: {profit:.2%}")
print(f"Probability of >10% Gain: {ten_gain:.2%}")
print(f"Probability of >10% Loss: {ten_loss:.2%}")
print(f"Value at Risk (5% worst): ${var:.2f} ({var/last_price:.2%} loss)")

print(f"\n--- Forecast Results in 252 Business Days (Last Simulated Day) ---")
print(f"Median Simulated Price: ${final_median_price:.2f}")
print(f"Median Return: {final_return:+.2%}")
print(f"25% Percentile: ${final_p25:.2f} ({final_p25_return:+.2%})")
print(f"75% Percentile: ${final_p75:.2f} ({final_p75_return:+.2%})")
print(f"90% Confidence Interval: (${final_p5:.2f}, ${final_p95:.2f})")
print(f"Probability of Profit: {final_profit:.2%}")
print(f"Probability of >10% Gain: {final_ten_gain:.2%}")
print(f"Probability of >10% Loss: {final_ten_loss:.2%}")
print(f"Value at Risk (5% worst): ${final_var:.2f} ({final_var/last_price:.2%} loss)")